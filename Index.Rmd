---
title: "Jointures et formats long et large"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
    df_print: default
runtime: shiny_prerendered
description: >
  Brève introduction aux jointures et aux formats long et large.
---


```{r setup,include=FALSE}
library(dplyr)
library(ggplot2)
library(tidyr)
library(learnr)

experiment2017<-read.csv("experiment2017.csv")
interview2019<-read.csv("interview2019.csv")


MergedData<-inner_join(experiment2017,interview2019,by=c("Farmer"="Name"))

LongData <- MergedData %>%
  pivot_longer(cols=Control:Treatment, names_to="Plot_type",values_to="Yield")


```

# Joindre et transformer des données


## Vue d'ensemble

Ce tutoriel donne une brève introduction à certaines fonctions additionnelles de manipulation de données très utiles :

- Joindre deux tableaux de donnees en utilisant les fonctions `_join()` du package `dplyr`.

- Passer du format long a large et inversement en utilisant les fonctions `pivot_()` du package `tidyr`.

Ces fonctions peuvent être incroyablement utiles pour rassembler des données provenant de sources multiples dans un format cohérent et ordonné, prêt à être analysé. Essayer de reproduire ce type de fonctionnalité dans Excel prend énormément de temps et présente un fort risque d'erreur humaine.

Ce tutoriel ne fournit que quelques exemples, pour montrer comment le code fonctionne, mais des liens sont fournis vers des ressources plus complètes si vous souhaitez en savoir plus.

Si vous essayez de reproduire ce qui se trouve dans ce tutoriel sur votre ordinateur, notez que le package `tidyr` n'est peut-être pas déjà installée, donc assurez-vous de l'avoir installé et chargé avant de suivre le code dans RStudio. Vous devriez déjà avoir `dplyr` installé dans RStudio, mais vous devrez quand même vous rappeler de le charger.

```
library(dplyr)
library(tidyr)
```

## Données pour cette session

Dans cette session, nous utiliserons deux tableaux de données fictifs. Le premier, appelé `experiment2017` est une expérience sur une exploitation agricole, où chacun des 20 agriculteurs a recueilli des valeurs de rendement pour deux parcelles, l'une où un nouveau traitement a été appliqué (colonne "Treatement"), et l'autre où ce nouveau traitement n'a pas été appliqué (colonne "Control").  

L'autre tableau de données appelé `interview2019` contient les réponses de 71 agriculteurs - dont certains ont participé à l'experiment2017 - lorsqu'on leur a demandé s'ils accepteraient de participer à une nouvelle expérience (colonne "Accept"). Vous pouvez télécharger ces deux jeux de données [ici](https://github.com/stats4sd/R-course-FR-07-MergeReshape/raw/main/data-merge.zip) 

Notre objectif sera de combiner ces deux tableaux de données afin d'explorer si, pour un agriculteur, les rendements obtenus pour l'expérience de 2017 semblent etre liés à son souhait de participer à une nouvelle expérience.


Vous pouvez consulter le jeu de données `experiment2017` ici :


```{r,echo=FALSE}
DT::datatable(experiment2017)
```

Et vous pouvez explorer le jeu de données `interview2019` ci-dessous :


```{r,echo=FALSE}
DT::datatable(interview2019)
```


## Jointures complètes

dplyr dispose d'un certain nombre de fonctions utiles pour fusionner des données. Pour chacune, nous devons avoir deux tableaux de données qui partagent une ou plusieurs variables d'identification communes. Dans cette session, nous allons couvrir deux de ces fonctions : `full_join()` et `inner_join()`.


Le resultat de `full_join()` nous donnera un tableau de données qui contient toutes les lignes des deux ensembles de données que nous essayons de fusionner, qu'il y ait ou non une correspondance dans les variables d'identification. S'il n'y a pas de correspondance, des valeurs manquantes seront ajoutees pour les colonnes du tableau de données correspondant.

Voici un diagramme qui tente d'expliquer comment marche `full_join()` en utilisant les tableaux de données `experiment2017` et `interview2019` :


```{r echo=FALSE, out.width="85%", fig.align='center'}
knitr::include_graphics("images/fulljoinCCRP.jpg")
```

<br>


Dans `full_join()`, nous devons fournir les noms des deux tableaux de données, et ensuite l'argument "by" pour fournir la ou les variables d'identification communes. Dans notre cas, nous avons une variable ID commune qui est le nom des agriculteurs. Cette variable est la colonne `Farmer` pour le tableau de données `experiment2017` et la colonne `Name` pour le tableu de données `interview2019`. Ainsi, en utilisant la commande suivante, nous obtiendrons une sortie contenant tous les agriculteurs et toutes les colonnes des deux ensembles de données :


```{r fj,exercise=TRUE}
full_join(experiment2017,interview2019,by=c("Farmer"="Name"))
```

Comme vous le voyez, dans l'instruction *by*, nous avons indiqué le nom de colonne `Farmer` du premier tableau de données indiqué (`experiment2017`) à gauche du signe égal, et le nom de colonne `Name` du deuxième tableau de données (`interview2019`) à sa droite. L'ordre est important.


Notez également qu'aucun des agriculteurs n'a le même nom, mais en général cela peut facilement arriver, ce qui perturberait notre jointure car R serait incapable de savoir comment combiner les multiples lignes avec les mêmes noms. C'est pourquoi vous devez toujours utiliser une variable ID - ou une combinaison de variables - dont vous **savez** qu'elle sera unique pour chaque agriculteur. Une bonne façon de s'en assurer est de générer et d'attribuer vous-même un ID unique à chaque agriculteur.


Bref, revenons au résultat de `full_join()`. Nous avons commencé avec deux tableaux de données, l'un avec 20 agriculteurs, l'autre avec 71 agriculteurs, et le tableau de données résultant contient 80 lignes, qui est le nombre total d'agriculteurs distincts. Si vous vérifiez attentivement le résultat, vous verrez qu'il y a un certain nombre de valeurs manquantes (`NA`). Ceci est dû au fait que nous avons conservé les données de chaque agriculteur. Certains agriculteurs sont dans les deux tableaux de données, mais tous les autres agriculteurs ne sont que dans l'un des deux tableaux de données. Lorsque c'est le cas, le reste des données est rempli de NAs. 


Mais ce n'est pas ce que nous voulons. Ce que nous voulons, c'est conserver uniquement les données combinées pour les agriculteurs qui sont dans les deux ensembles de données. Nous pouvons y parvenir en utilisant `inner_join()`.

## Jointures internes

`inner_join()` nous donnera un tableau de données de sortie qui contient seulement les lignes qui ou l'identifiant existe dans les deux tableaux de données d'origine.

```{r echo=FALSE, out.width="85%", fig.align='center'}
knitr::include_graphics("images/innerjoinCCRP.jpg")
```

<br>

Ainsi, dans notre exemple, nous n'inclurons que les agriculteurs qui ont participé à l'expérience de 2017 **et** à qui on a demandé s'ils étaient prêts à participer à une nouvelle expérience. Nous n'aurons pas de valeurs manquantes créées avec un `inner_join`. 


```{r ij, exercise=TRUE}
inner_join(experiment2017,interview2019,by=c("Farmer"="Name"))

```

Comme vous le voyez, nous avions 20 lignes pour un des tableaux de données et 71 lignes pour l'autre, et après avoir utilisé `inner_join`, il ne nous reste que 11 lignes. Ce sont les agriculteurs pour lesquels nous pouvons faire notre analyse. Sauvegardons donc ce nouveau tableau de données comme un objet appelé `MergedData`, pour l'utiliser dans les étapes suivantes.

```{r assign, exercise=TRUE}
MergedData<-inner_join(experiment2017,interview2019,by=c("Farmer"="Name"))

```

Rappelez-vous qu'il est normal que nous ne voyions aucune sortie, parce que nous sauvegardons le résultat comme un objet et ne demandons pas à R de nous montrer quoi que ce soit.

## Autres jointures

Ces deux fonctions de jointure fournissent une fonctionnalité qui couvrira la plupart des besoins courants que vous pourriez avoir pour fusionner deux ensembles de données.
Mais il y a plusieurs autres façons de combiner des données dans dplyr avec d'autres fonctions `_join()`, qui valent la peine d'être connues pour d'autres situations.

Il y a un tutoriel complet sur toutes les différentes fonctions de jointure dans `dplyr` ici :
https://rpubs.com/williamsurles/293454


## Format large et format long

Malgré la présence de deux mesures de rendement par agriculteur, l'ensemble de données de l'expérience 2017 ne comporte qu'une seule ligne par agriculteur. Cela est dû au fait qu'il s'agit d'un format dit "large". Pour mieux comprendre ce que nous entendons par format "large", imaginons quelques agriculteurs qui auraient collecté 4 mesures de rendement. Une pour chacun de trois traitements, et une pour la parcelle de contrôle. Les données de ces agriculteurs ressembleraient à ce qui suit :


```{r echo=FALSE, out.width="50%", fig.align='center'}
knitr::include_graphics("images/WideCCRP.JPG")
```



Mais ce n'est pas le format sur lequel R aime généralement opérer - R préfère en general le format "long" où nous avons une ligne par observation. Dans notre petit exemple, nous avions 4 observations par agriculteur, donc au format "long", nous aurions quatre lignes pour chaque agriculteur et au lieu de 4 variables numériques de rendement, nous n'aurions que deux colonnes. Une colonne numérique contenant les valeurs de rendement, et une colonne catégorielle indiquant le traitement ou le type de parcelles sur lesquelles le rendement a été mesuré :

```{r echo=FALSE, out.width="35%", fig.align='center'}
knitr::include_graphics("images/longCCRP.jpg")
```

Et si vous pensez à quand nous avons utilisé `ggplot2`, nous avions toujours une variable unique pour notre argument y, et nous utilisions des variables catégorielles pour le séparer en groupes, facettes, couleurs et c'était similaire pour la modélisation. Nous avions une seule variable dépendante et les groupes de l'Anova étaient définis par une variable catégorielle. Donc, en général, les formats longs fonctionnent beaucoup mieux que les formats larges pour faire des graphiques ou de la modélisation statistique.


Et pour nous aider à analyser notre tableau de donnees `MergedData` où les données expérimentales sont en format large, nous devons les transformer en format long.

La fonction `pivot_longer()` du package `tidyr` est l'une des fonctions les plus intuitives a utiliser pour faire ca. 

```{r gather0,exercise=TRUE}
MergedData %>%
  pivot_longer(cols=Control:Treatment, names_to="Plot_type",values_to="Yield")

```

Si on utilise l'operateur pipe avant d'appeler la fonction, alors on doit fournir trois arguments :

* Quelles sont les colonnes des données que nous ramener en une seule longue colonne. Nous ne voulons pas toutes les colonnes, seulement celles qui font référence à l'attribut commun, c'est-à-dire les mesures de rendement. Nous pourrions utiliser la fonction c() pour indiquer les colonnes à combiner : `c(Control, Treatement)`, mais nos deux colonnes sont côte à côte, nous pouvons donc utiliser un léger raccourci en utilisant les deux points : `PremièreColonne:DernièreColonne`. Dans notre cas, nous n'avons que deux colonnes, donc ce n'est pas vraiment un raccourci. Notez que nous n'avons pas besoin d'utiliser les guillemets lorsque nous faisons référence à des colonnes existantes. Cet argument est appelé "cols".   

* Le nom de la nouvelle colonne qui va contenir le nom des colonnes d'origine des valeurs de notre longue colonne. Cet argument est appelé "names_to" - il nécessite une entrée entre guillemets. Dans notre cas, les colonnes regrouper sont les deux différents types de parcelles (traitement ou contrôle), donc nous pouvons l'appeler "Plot_type" par exemple.  

* Le nom de la nouvelle longue colonne où les valeurs des données seront placées dans les données restructurées. Cet argument est appelé "values_to" - il nécessite une entrée entre guillemets egalement. Dans notre cas, les valeurs font référence au rendement dans la parcelle, il est donc logique de l'appeler "Yield" (traduction anglaise de rendement).  

Si je n'utilisais pas l'operateur pipe, le premier argument de cette fonction devrait bien entendu être le tableau de données.


Notez que ce nouveau tableau de données a 22 lignes - 1 ligne pour chaque type de parcelle de chaque agriculteur (11 agriculteurs).

Dans RStudio, vous pouvez voir cela dans le panneau d'environnement ; ou en utilisant la fonction `dim()` pour obtenir les dimensions. Je vais assigner le resultat de l'étape précédente a un nouvel objet, appelé `LongData` et ensuite vérifier les dimensions de cette façon pour comparer les tableaux de données.


```{r gather1, exercise=TRUE}
LongData<- MergedData %>%
  pivot_longer(cols=Control:Treatment, names_to="Plot_type",values_to="Yield")

dim(LongData)
dim(MergedData)
```

Le fait de disposer de données au format long facilite grandement l'analyse, la representation graphique ou la manipulation.



### Répondre à notre question initiale

Rappelez-vous que notre objectif était d'explorer la relation entre le résultat de l'expérience de 2017 et la volonté de participer à une nouvelle expérience. Il existe plusieurs graphiques que nous pourrions réaliser à cette fin. Un bon exemple est de montrer le rendement sur l'axe des y, le type de parcelle sur l'axe des x, de tracer des lignes reliant les rendements d'un même agriculteur de sorte que chaque ligne représente un agriculteur, et d'ajouter de la couleur aux lignes selon que l'agriculteur a accepté ou non de participer à une nouvelle expérience :

```{r gather2, exercise=TRUE}
LongData %>%
  ggplot(aes(x=Plot_type, y=Yield, color=Accept, group=Farmer))+
  geom_line()
```
Remarquez que c'est l'esthétique du groupe qui définit quels sont les points reliés par les lignes. Dans notre cas, ce sont les points correspondant à un même agriculteur.

Nous pouvons voir que la plupart des lignes qui descendent sont rouges, c'est-à-dire que la plupart des agriculteurs qui ont vu une baisse de rendement entre les parcelles de contrôle et de traitement lors de l'expérimentation 2017, n'ont pas voulu participer à une nouvelle expérimentation selon l'entretien de 2019. En revanche, les lignes qui vont vers le haut sont bleues. Cela pourrait être plus facile à voir en utilisant des facettes :

```{r gather3, exercise=TRUE}
LongData %>%
  ggplot(aes(x=Plot_type, y=Yield, color=Accept, group=Farmer))+
  geom_line()+
  facet_wrap(~Accept)
```

### Passer au format large


Si nous avions nos données au format long et que nous voulions passer au format large, nous pourrions utiliser la fonction `pivot_wider()`, qui est en fait l'inverse de la fonction `pivot_longer()`. Elle nécessite donc les entrées inverses :

```{r gather4, exercise=TRUE}
LongData %>%
      pivot_wider(names_from=Plot_type,values_from=Yield)
```

* La colonne de noms à partir de laquelle chaque valeur unique de notre longue colonne deviendra l'un des noms de colonne dans le tableau de données au format large. Cet argument est "names_from".  
* La longue colonne de valeurs qui constituera le contenu de ces nouvelles colonnes. Cet argument est "values_from".  

Donc dans notre cas, la colonne "names_from" est `Plot_type` et la colonne "values_from" est `Yield`.

Nous avons récupéré nos données au format large !



## Autres transformations

Comme pour les fonctions `_join()`, il existe d'autres fonctions dans le package tidyr pour transformer les donnees. Si vous souhaitez en savoir plus à ce sujet, vous pouvez jeter un oeil ici par exemple : https://juba.github.io/tidyverse/12-tidyr.html#les-verbes-de-tidyr.